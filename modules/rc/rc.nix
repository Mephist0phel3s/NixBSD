{ pkgs, config, lib, ...}: with lib;
let
  cfg = config.rc;
  mkRcScript = {
    name
  , command
  , commandArgs
  , shell
  , rc
  , requires
  , before
  , keywords
  , hasPidfile
  , commands
  , ...
  }:
  let
    extraCommands = builtins.attrNames (builtins.removeAttrs commands);
  in pkgs.stdenv.writeTextFile {
    name = "${name}.in";
    text = ''
      #!${shell}${shell.shellPath or ""}
      # This file generated by nixbsd. It is not bespoke configuration! Do not modify!

      # PROVIDE: ${name}
    '' + optionalString ((builtins.length requires) != 0) ''
      # REQUIRE: ${concatStringsSep " " requires}
    '' + optionalString ((builtins.length before) != 0) ''
      # BEFORE: ${concatStringsSep " " before}
    '' + optionalString ((builtins.length keywords) != 0) ''
      # KEYWORD: ${concatStringsSep " " keywords}
    '' + ''

      . ${rc}/etc/rc.subr

      name="${name}"
      rcvar="${name}_enabled"
      command="${command}"
      command_args="${commandArgs}"
    '' + optionalString hasPidfile ''
      pidfile="/var/run/${name}.pid"
    '' + optionalString ((builtins.length extraCommands) != 0) ''
      extra_commands="${concatStringsSep " " extraCommands}"
    '' + concatStringsSep "" (attrValues (builtins.mapAttrs (cmd_name: cmd_value: ''
      ${cmd_name}_cmd="${name}_${cmd_name}"
    '') commands)) + ''

    '' + concatStringsSep "\n" (attrValues (builtins.mapAttrs (cmd_name: cmd_value: ''
      ${name}_${cmd_name}() {
      ${cmd_value}
      }
    '') commands)) + ''

      load_rc_config ${name}
      run_rc_command "$1"
    '';
  };
  mkRcDir = scriptCfg: pkgs.runCommand "rc.d" { scripts = map mkRcScript scriptCfg; } ''
    mkdir -p $out
    ln -s $scripts $out
  '';
in {
  options.rc.enabled = (mkEnableOption "rc");
  options.rc.entries = {
    type = listOf types.submodule ({config, ...}: {
      options.name = mkOption {
        type = types.strMatching "[_a-zA-Z][_a-zA-Z0-9]*";
        description = "The name of the service. Gets used as a variable name.";
      };

      options.command = mkOption {
        type = types.storePath;
        description = "The executable to run to start this service";
      };

      options.shell = mkOption {
        type = types.shellPackage;
        description = "The shell with which to run the rc-script when invoked directly. Probably don't change this.";
        default = pkgs.bash;
      };

      options.rc = mkOption {
        type = types.pkg;
        description = "The rc derivation from which to source internal scripts during rc-script execution. Probably don't change this.";
        default = pkgs.freebsd.rc;
      };

      options.keywordNojail = mkOption {
        type = types.bool;
        description = "Whether this service should be disabled in jails.";
      };

      options.keywordNojailvnet = mkOption {
        type = types.bool;
        description = "Whether this service should be disabled in jails without vnets.";
      };

      options.keywordFirstboot = mkOption {
        type = types.bool;
        description = "Whether this service should only be run on the very first system boot.";  # TODO is this right?
      };

      options.keywordNostart = mkOption {
        type = types.bool;
        description = "Whether this service should only not be started automatically on boot.";
      };

      options.keywordSuspend = mkOption {
        type = types.bool;
        description = "Whether this service should be stopped on system suspend.";  # TODO is this right?
      };

      options.keywordResume = mkOption {
        type = types.bool;
        description = "Whether this service should be started on resume from suspend.";  # TODO is this right?
      };

      options.keywordShutdown = mkOption {
        type = types.bool;
        description = "Whether this service should be automatically stopped at system shutdown.";
      };

      options.require = mkOption {
        type = listOf str;
        description = "The services or phases that must be started before this service starts.";
      };

      options.before = mkOption {
        type = listOf str;
        description = "The services or phases before which this service must be started.";
      };

      options.keywords = mkOption {
        type = listOf str;
        description = "The service keywords, used for filtering based on well-known service considerations.";
      };

      config.keywords = []
        + optionals config.keywordShutdown ["shutdown"]
        + optionals config.keywordNojail ["nojail"]
        + optionals config.keywordNojailvnet ["nojailvnet"]
        + optionals config.keywordFirstboot ["firstboot"]
        + optionals config.keywordNostart ["nostart"]
        + optionals config.keywordSuspend ["suspend"]
        + optionals config.keywordResume ["resume"]
        ;

      options.commands = mkOption {
        type = attrsOf str;
        description = "A mapping from command name to command text.";
        default = {};
      };
    });
  };

  config = mkIf cfg.enabled {
    # TODO whatever the hell needs to be done to hook rc up to init
    # TODO add rc.d to etc
  };
}
