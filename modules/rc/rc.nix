{ pkgs, config, lib, ...}: with lib;
let
  identType = types.strMatching "[_a-zA-Z][_a-zA-Z0-9]*";
  defaultCommands = ["start" "stop" "restart" "status" "enable" "disable" "delete" "describe" "extracommands" "poll" "enabled" "rcvar"];
  cfg = config.rc;
  mkRcScript = {
    provides
  , command
  , commandArgs
  , shell
  , requires
  , before
  , keywords
  , hasPidfile
  , commands
  , dummy
  , description
  , binDeps
  , ...
  }:
  let
    extraCommands = builtins.attrNames (builtins.removeAttrs commands defaultCommands);
    name = if (builtins.isString provides) then provides else builtins.elemAt provides 0;
  in pkgs.writeTextFile {
    name = "${name}.in";
    executable = true;
    text = ''
      #!${shell}${shell.shellPath or ""}
      # This file generated by nixbsd. It is not bespoke configuration! Do not modify!

      # PROVIDE: ${if (builtins.isString provides) then provides else (concatStringsSep " " provides)}
    '' + optionalString ((builtins.length requires) != 0) ''
      # REQUIRE: ${concatStringsSep " " requires}
    '' + optionalString ((builtins.length before) != 0) ''
      # BEFORE: ${concatStringsSep " " before}
    '' + optionalString ((builtins.length keywords) != 0) ''
      # KEYWORD: ${concatStringsSep " " keywords}
    '' + optionalString ((builtins.stringLength description) != 0) ''
      # DESCRIPTION: ${description}
    '' + optionalString (!dummy) (''

      . /etc/rc.subr

      name="${name}"
      rcvar="${name}_enabled"
      # maybe a hack, maybe necessary: auto-enable all modules since we're only including them if they're enabled
      ${name}_enabled=yes
      export PATH=${makeBinPath binDeps}:$PATH
    '' + optionalString (!(builtins.isNull command)) ''
      command="${command}"
    '' + optionalString (!(builtins.isNull commandArgs)) ''
      command_args="${commandArgs}"
    '' + optionalString hasPidfile ''
      pidfile="/var/run/${name}.pid"
    '' + optionalString ((builtins.length extraCommands) != 0) ''
      extra_commands="${concatStringsSep " " extraCommands}"
    '' + concatStringsSep "" (attrValues (builtins.mapAttrs (cmd_name: cmd_value: ''
      ${cmd_name}_cmd="${name}_${cmd_name}"
    '') commands)) + ''

    '' + concatStringsSep "\n" (attrValues (builtins.mapAttrs (cmd_name: cmd_value: ''
      ${name}_${cmd_name}() {
      ${cmd_value}
      }
    '') commands)) + ''

      load_rc_config ${name}
      run_rc_command "$1"
    '');
  };
  mkRcDir = scriptCfg: pkgs.runCommand "rc.d" { scripts = builtins.map mkRcScript scriptCfg; } ''
    mkdir -p $out
    ln -s $scripts $out
  '';
in {
  options.rc.enabled = (mkEnableOption "rc") // { default = true; };
  options.rc.package = mkOption {
    type = types.package;
    default = pkgs.freebsd.rc;
    description = "The FreeBSD rc package to use. Expected contents: /etc/rc, /etc/rc.subr, ...";
  };
  options.rc.services = mkOption {
    default = {};
    type = types.attrsOf (types.submodule ({config, ...}: {
      options.provides = mkOption {
        type = types.either identType (types.listOf identType);
        description = "The name of the service. Gets used as a variable name.";
      };

      options.description = mkOption {
        type = types.str;
        description = "A short description of the service. Placed as a comment in the script for debugging.";
        default = "";
      };

      options.command = mkOption {
        type = types.nullOr types.pathInStore;
        description = "The executable to run to start this service";
        default = null;
      };

      options.commandArgs = mkOption {
        type = types.nullOr types.str;
        description = "The args with which to launch `command`";
        default = null;
      };

      options.hasPidfile = mkOption {
        type = types.bool;
        default = false;
        description = "Whether to automatically create a pidfile";
      };

      options.shell = mkOption {
        type = types.shellPackage;
        description = "The shell with which to run the rc-script when invoked directly. Probably don't change this.";
        default = pkgs.bash;
      };

      options.keywordNojail = mkOption {
        type = types.bool;
        description = "Whether this service should be disabled in jails.";
        default = false;
      };

      options.keywordNojailvnet = mkOption {
        type = types.bool;
        description = "Whether this service should be disabled in jails without vnets.";
        default = false;
      };

      options.keywordFirstboot = mkOption {
        type = types.bool;
        description = "Whether this service should only be run on the very first system boot.";  # TODO is this right?
        default = false;
      };

      options.keywordNostart = mkOption {
        type = types.bool;
        description = "Whether this service should only not be started automatically on boot.";
        default = false;
      };

      options.keywordSuspend = mkOption {
        type = types.bool;
        description = "Whether this service should be stopped on system suspend.";  # TODO is this right?
        default = false;
      };

      options.keywordResume = mkOption {
        type = types.bool;
        description = "Whether this service should be started on resume from suspend.";  # TODO is this right?
        default = false;
      };

      options.keywordShutdown = mkOption {
        type = types.bool;
        description = "Whether this service should be automatically stopped at system shutdown.";
        default = false;
      };

      options.requires = mkOption {
        type = types.listOf types.str;
        description = "The services or phases that must be started before this service starts.";
        default = [];
      };

      options.before = mkOption {
        type = types.listOf types.str;
        description = "The services or phases before which this service must be started.";
        default = [];
      };

      options.keywords = mkOption {
        type = types.listOf types.str;
        description = "The service keywords, used for filtering based on well-known service considerations.";
        default = [];
      };

      config.keywords = []
        ++ optionals config.keywordShutdown ["shutdown"]
        ++ optionals config.keywordNojail ["nojail"]
        ++ optionals config.keywordNojailvnet ["nojailvnet"]
        ++ optionals config.keywordFirstboot ["firstboot"]
        ++ optionals config.keywordNostart ["nostart"]
        ++ optionals config.keywordSuspend ["suspend"]
        ++ optionals config.keywordResume ["resume"]
        ;

      options.commands = mkOption {
        type = types.attrsOf types.str;
        description = "A mapping from command name to command text.";
        default = {};
      };

      options.binDeps = mkOption {
        type = types.listOf types.package;
        description = "Any packages whose bin directories should be made available during command execution.";
        default = [pkgs.coreutils pkgs.freebsd.bin];
      };

      options.dummy = mkOption {
        type = types.bool;
        description = "Whether this is a dummy script, i.e. a stage ordering marker.";
        default = false;
      };
    }));
  };

  config = mkIf cfg.enabled {
    environment.etc."rc" = {
      source = "${cfg.package}/etc/*";
      target = ".";
    };
    environment.etc."rc.d".source = mkRcDir (attrValues cfg.services);
  };
}
